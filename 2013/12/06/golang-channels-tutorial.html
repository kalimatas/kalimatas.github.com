<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="/static/css/style.css" type="text/css" />
	<link rel="stylesheet" href="/static/css/pygments.css" type="text/css" />
	<link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAFxYUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEREREREREREREREREREREQAAAAAAAAAAEREREREREREAAAAAAAAAABEREREREREREREREREREREAAAAAAAAAABEREREREREREREREREREREREREREREREQAAAAAAAAAAEREREREREREREREREREREREREREREREREREREREREREAAAAAAAAAAP//AAAAAAAA//8AAAAAAAAAAAAA//8AAAAAAAAAAAAAAAAAAP//AAAAAAAAAAAAAAAAAAAAAAAA" />
	<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Golang Channels Tutorial | Alexander Guz’s blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Golang Channels Tutorial" />
<meta name="author" content="Alexander Guz" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Basic introduction to Golang channels." />
<meta property="og:description" content="Basic introduction to Golang channels." />
<link rel="canonical" href="https://guzalexander.com/2013/12/06/golang-channels-tutorial.html" />
<meta property="og:url" content="https://guzalexander.com/2013/12/06/golang-channels-tutorial.html" />
<meta property="og:site_name" content="Alexander Guz’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-12-06T11:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Golang Channels Tutorial" />
<meta name="twitter:site" content="@kalimatas" />
<meta name="twitter:creator" content="@Alexander Guz" />
<script type="application/ld+json">
{"headline":"Golang Channels Tutorial","dateModified":"2013-12-06T11:00:00+01:00","datePublished":"2013-12-06T11:00:00+01:00","url":"https://guzalexander.com/2013/12/06/golang-channels-tutorial.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://guzalexander.com/2013/12/06/golang-channels-tutorial.html"},"author":{"@type":"Person","name":"Alexander Guz"},"description":"Basic introduction to Golang channels.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>

	<section class="container">
		<nav class="menu">
			<ul>
				<li><a class="nav-link fancy-hover" href="/"><span>Home</span></a></li>
				<li><a class="nav-link fancy-hover" href="/archive/"><span>Archive</span></a></li>
				<li><a class="nav-link fancy-hover" href="/about/"><span>About</span></a></li>
			</ul>
			<ul>
				<li>
					<a class="nav-link fancy-hover" href="https://twitter.com/kalimatas" target="_blank" >
						<span>
							<img alt="Twitter" width="18" height="18" title="Twitter" src="/static/img/twitter_new.svg" />
						</span>
					</a>
				</li>
				<li>
					<a class="nav-link fancy-hover" href="https://github.com/kalimatas" target="_blank">
						<span>
							<img alt="GitHub" width="18" height="18" title="GitHub" src="/static/img/github_new.svg" />
						</span>
					</a>
				</li>
				<li>
					<a class="nav-link fancy-hover" href="https://linkedin.com/in/kalimatas" target="_blank" >
						<span>
							<img alt="LinkedIn" width="18" height="18" title="LinkedIn" src="/static/img/linkedin_new.svg" />
						</span>
					</a>
				</li>
			</ul>
		</nav>

		<section class="main-wrapper">
			<section class="main">
				<article>
	
	<h1><span>Golang Channels Tutorial</span></h1>
	<section class="post-meta">
		
		<time>December 6, 2013</time> • <span class="reading-time" title="Estimated read time">
  
  
    15 mins read
  
</span>

	</section>
	
	<section class="description">
		Basic introduction to Golang channels.
	</section>
	
	<section id="article-content">
		<p><a href="http://golang.org/">Golang</a> has built-in instruments for writing concurrent programs. Placing a <a href="http://golang.org/ref/spec#Go_statements">go</a> statement before a function call starts the execution of that function as an independent concurrent thread in the same address space as the calling code. Such thread is called <code class="language-plaintext highlighter-rouge">goroutine</code> in Golang. Here I should mention that concurrently doesn’t always mean in parallel. Goroutines are means of creating concurrent architecture of a program which could possibly execute in parallel in case the hardware allows it. There is a great talk on that topic <a href="http://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a>.</p>

<p>Let’s start with an example of a goroutine:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Start a goroutine and execute println concurrently</span>
     <span class="k">go</span> <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>
     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This program will print <code class="language-plaintext highlighter-rouge">main function message</code> and <em>possibly</em> <code class="language-plaintext highlighter-rouge">goroutine message</code>. I say <em>possibly</em> because spawning a goroutine has some peculiarities. When you start a goroutine the calling code (in our case it is the <code class="language-plaintext highlighter-rouge">main</code> function) doesn’t wait for a goroutine to finish, but continues running further. After calling a <code class="language-plaintext highlighter-rouge">println</code> the main  function ends its execution and in Golang it means stopping of execution of the whole program with all spawned goroutines. But before it happens our goroutine could possibly finish executing its code and print the <code class="language-plaintext highlighter-rouge">goroutine message</code> string.</p>

<p>As you understand there must be some way to avoid such situations. And for that there are <strong>channels</strong> in Golang.</p>

<h2 id="channels-basics">Channels basics</h2>

<p>Channels serve to synchronize execution of concurrently running functions and to provide a mechanism for their communication by passing a value of a specified type. Channels have several characteristics: the type of element you can send through a channel, capacity (or buffer size) and direction of communication specified by a <code class="language-plaintext highlighter-rouge">&lt;-</code> operator. You can allocate a channel using the built-in function <a href="http://golang.org/ref/spec#Making_slices_maps_and_channels">make</a>:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">i</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c">// by default the capacity is 0</span>
<span class="n">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="c">// non-zero capacity</span>

<span class="n">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>          <span class="c">// can only read from</span>
<span class="n">w</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="o">&lt;-</span> <span class="p">[]</span><span class="n">os</span><span class="o">.</span><span class="n">FileInfo</span><span class="p">)</span> <span class="c">// can only write to</span></code></pre></figure>

<p>Channels are first-class values and can be used anywhere like other values: as struct elements, function arguments, function returning values and even like a type for another channel:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">// a channel which:</span>
<span class="c">//  - you can only write to</span>
<span class="c">//  - holds another channel as its value</span>
<span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="o">&lt;-</span> <span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

<span class="c">// function accepts a channel as a parameter</span>
<span class="k">func</span> <span class="n">readFromChannel</span><span class="p">(</span><span class="n">input</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="c">// function returns a channel</span>
<span class="k">func</span> <span class="n">getChannel</span><span class="p">()</span> <span class="k">chan</span> <span class="kt">bool</span> <span class="p">{</span>
     <span class="n">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span></code></pre></figure>

<p>For writing and reading operations on channel there is a <a href="http://golang.org/ref/spec#Receive_operator">&lt;-</a> operator. Its position relatively to the channel variable determines whether it will be a read or a write operation. The following example demonstrates its usage, but I have to warn you that this code <strong>does not work</strong> for some reasons described later:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span>    <span class="c">// write to a channel</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span> <span class="c">// read from a channel</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Now, as we know what channels are, how to create them and perform basic operations on them, let’s return to our very first example and see how channels can help us.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Create a channel to synchronize goroutines</span>
     <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

     <span class="c">// Execute println in goroutine</span>
     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>

          <span class="c">// Tell the main function everything is done.</span>
          <span class="c">// This channel is visible inside this goroutine because</span>
          <span class="c">// it is executed in the same address space.</span>
          <span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span>
     <span class="p">}()</span>

     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
     <span class="o">&lt;-</span><span class="n">done</span> <span class="c">// Wait for the goroutine to finish</span>
<span class="p">}</span></code></pre></figure>

<p>This program will print both messages without any possibilities. Why? <code class="language-plaintext highlighter-rouge">done</code> channel has no buffer (as we did not specify its capacity). All operations on unbuffered channels block the execution until both sender and receiver are ready to communicate. That’s why unbuffered channels are also called synchronous. In our case the reading operation <code class="language-plaintext highlighter-rouge">&lt;-done</code> in the main function will block its execution until the goroutine will write data to the channel. Thus the program ends only after the reading operation succeeds.</p>

<p>In case a channel has a buffer all read operations succeed without blocking if the buffer is not empty, and write operations - if the buffer is not full. These channels are called asynchronous. Here is an example to demonstrate the difference between them:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">message</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="c">// no buffer</span>
     <span class="n">count</span> <span class="o">:=</span> <span class="m">3</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
               <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"send message"</span><span class="p">)</span>
               <span class="n">message</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"message %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
          <span class="p">}</span>
     <span class="p">}()</span>

     <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span> <span class="o">*</span> <span class="m">3</span><span class="p">)</span>

     <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">message</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In this example <code class="language-plaintext highlighter-rouge">message</code> is a synchronous channel and the output of the program is:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">send message
// wait for 3 seconds
message 1
send message
send message
message 2
message 3</code></pre></figure>

<p>As you see after the first write to the channel in the goroutine all other writing operations on that channel are blocked until the first read operation is performed (about 3 seconds later).</p>

<p>Now let’s provide a buffer to out <code class="language-plaintext highlighter-rouge">message</code> channel, i.e. the creation line will look as  <code class="language-plaintext highlighter-rouge">message := make(chan string, 2)</code>. This time the output will be the following:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">send message
send message
send message
// wait for 3 seconds
message 1
message 2
message 3</code></pre></figure>

<p>Here we see that all writing operations are performed without waiting for the first read for the buffer of the channel allows to store all three messages. By changing channels capacity we can control the amount of information being processed thus limiting throughput of a system.</p>

<h2 id="deadlock">Deadlock</h2>

<p>Now let’s get back to our not working example with read/write operations.</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     <span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span>    <span class="c">// write to a channel</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span> <span class="c">// read from a channel</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>On running you’ll get this error (details will differ):</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
     /fullpathtofile/channelsio.go:5 +0x54
exit status 2</code></pre></figure>

<p>The error you got is called a <strong>deadlock</strong>. This is a situation when two goroutines wait for each other and non of them can proceed its execution. Golang can detect deadlocks in runtime that’s why we can see this error. This error occurs because of the blocking nature of communication operations.</p>

<p>The code here runs within a single thread, line by line, successively. The operation of writing to the channel (<code class="language-plaintext highlighter-rouge">c &lt;- 42</code>) blocks the execution of the whole program because, as we remember, writing operations on a synchronous channel can only succeed in case there is a receiver ready to get this data. And we create the receiver only in the next line.</p>

<p>To make this code work we should had written something like:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
     
     <span class="c">// Make the writing operation be performed in</span>
     <span class="c">// another goroutine.</span>
     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> 
     	<span class="n">c</span> <span class="o">&lt;-</span> <span class="m">42</span> 
     <span class="p">}()</span>
     <span class="n">val</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c</span>
     <span class="nb">println</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h2 id="range-channels-and-closing">Range channels and closing</h2>

<p>In one of the previous examples we sent several messages to a channel and then read them. The receiving part of code was:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
	 <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">message</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>In order to perform reading operations without getting a deadlock we have to know the exact number of sent messages (<code class="language-plaintext highlighter-rouge">count</code>, to be exact), because we cannot read more then we sent. But it’s not quite convenient. It would be nice to be able to write more general code.</p>

<p>In Golang there is a so called <strong>range expression</strong> which allows to iterate through arrays, strings, slices, maps and channels. For channels, the iteration proceeds until the channel is closed. Consider the following example (does not work for now):</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">message</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>
     <span class="n">count</span> <span class="o">:=</span> <span class="m">3</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
               <span class="n">message</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"message %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
          <span class="p">}</span>
     <span class="p">}()</span>

     <span class="k">for</span> <span class="n">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">message</span> <span class="p">{</span>
          <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Unfortunately this code does not work now. As was mentioned above the <code class="language-plaintext highlighter-rouge">range</code> will work until the channel is closed explicitly. All we have to do is to close the channel with a  <a href="http://golang.org/ref/spec#Close">close</a> function. The goroutine will look like:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="n">message</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"message %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	 <span class="p">}</span>
     <span class="nb">close</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="p">}()</span></code></pre></figure>

<p>Closing a channel has one more useful feature - reading operations on closed channels do not block and always return default value for a channel type:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>
<span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>

<span class="c">// Will not block and will print false twice </span>
<span class="c">// because it’s the default value for bool type</span>
<span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">done</span><span class="p">)</span>
<span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">done</span><span class="p">)</span></code></pre></figure>

<p>This feature may be used for goroutines synchronization. Let’s recall one of our examples with synchronization (the one with <code class="language-plaintext highlighter-rouge">done</code> channel):</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>

          <span class="c">// We are only interested in the fact of sending itself, </span>
          <span class="c">// but not in data being sent.</span>
          <span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span>
     <span class="p">}()</span>

     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
     <span class="o">&lt;-</span><span class="n">done</span> 
<span class="p">}</span> </code></pre></figure>

<p>Here the <code class="language-plaintext highlighter-rouge">done</code> channel is only used to synchronize the execution but not for sending data. There is a kind of pattern for such cases:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Data is irrelevant</span>
     <span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>

     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="s">"goroutine message"</span><span class="p">)</span>

          <span class="c">// Just send a signal "I'm done"</span>
          <span class="nb">close</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
     <span class="p">}()</span>

     <span class="nb">println</span><span class="p">(</span><span class="s">"main function message"</span><span class="p">)</span>
     <span class="o">&lt;-</span><span class="n">done</span>
<span class="p">}</span> </code></pre></figure>

<p>As we close the channel in the goroutine the reading operation does not block and the main function continues to run.</p>

<h2 id="multiple-channels-and-select">Multiple channels and select</h2>

<p>In real programs you’ll probably need more than one goroutine and one channel. The more independent parts are - the more need for effective synchronization. Let’s look at more complex example:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">func</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="n">msg</span> <span class="kt">string</span><span class="p">,</span> <span class="n">delay</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">string</span> <span class="p">{</span>
     <span class="n">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>
     <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
               <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%s %d"</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
               <span class="c">// Wait before sending next message</span>
               <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span> <span class="o">*</span> <span class="n">delay</span><span class="p">)</span>
          <span class="p">}</span>
     <span class="p">}()</span>
     <span class="k">return</span> <span class="n">c</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">c1</span> <span class="o">:=</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="s">"first"</span><span class="p">,</span> <span class="m">300</span><span class="p">)</span>
     <span class="n">c2</span> <span class="o">:=</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="s">"second"</span><span class="p">,</span> <span class="m">150</span><span class="p">)</span>
     <span class="n">c3</span> <span class="o">:=</span> <span class="n">getMessagesChannel</span><span class="p">(</span><span class="s">"third"</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>

     <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
          <span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c1</span><span class="p">)</span>
          <span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c2</span><span class="p">)</span>
          <span class="nb">println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">c3</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Here we have a function that creates a channel and spawns a goroutine which will populate the channel with three messages in a specified interval. As we see the third channel <code class="language-plaintext highlighter-rouge">c3</code> has the least interval, thus we except its messages to appear prior to others. But the output will be the following:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">first 1
second 1
third 1
first 2
second 2
third 2
first 3
second 3
third 3</code></pre></figure>

<p>Obviously we got a successive output. That is because the reading operation on the first channel blocks for <code class="language-plaintext highlighter-rouge">300</code> milliseconds for each loop iteration and other operations must wait. What we actually want is to read messages from all channels as soon as they are any.</p>

<p>For communication operations on multiple channels there is a <a href="http://golang.org/ref/spec#Select_statements">select</a> statement in Golang. It’s much like the usual <code class="language-plaintext highlighter-rouge">switch</code> but all cases here are communication operations (both reads and writes). If the operation in <code class="language-plaintext highlighter-rouge">case</code> can be performed than the corresponding block of code executes. So, to accomplish what we want, we have to write:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
     <span class="k">select</span> <span class="p">{</span>
     <span class="k">case</span> <span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c1</span><span class="o">:</span>
          <span class="nb">println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
	 <span class="k">case</span> <span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c2</span><span class="o">:</span>
          <span class="nb">println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="k">case</span> <span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c3</span><span class="o">:</span>
          <span class="nb">println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
     <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Pay attention to the number <code class="language-plaintext highlighter-rouge">9</code>: for each of the channels there were 3 writing operations, that’s why I have to perform 9 loops of the select statement. In a program which is meant to run as a daemon there is a common practice to run <code class="language-plaintext highlighter-rouge">select</code> in an infinite loop, but here I’ll get a deadlock if I’ll run one.</p>

<p>Now we get the expected output, and non of reading operations block others. The output is:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">first 1
second 1
third 1 // this channel does not wait for others
third 2
third 3
second 2
first 2
second 3
first 3</code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Channels is a very powerful and interesting mechanism in Golang. But in order to use them effectively you have to understand how they work. In this article I tried to explain the very necessary basics. For further learning I recommend you look at the following:</p>

<ul>
  <li><a href="http://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a> - early mentioned talk from Rob Pike</li>
  <li><a href="http://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a></li>
  <li><a href="http://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a></li>
</ul>


	</section>
	<section id="share-page">
	<span>Share this page on</span>
	<a href="https://twitter.com/intent/tweet?text=Golang Channels Tutorial&url=https://guzalexander.com/2013/12/06/golang-channels-tutorial.html&via=&related=" rel="nofollow" target="_blank" title="Share on Twitter">Twitter</a> or
	<a href="https://www.reddit.com/submit?url=https://guzalexander.com/2013/12/06/golang-channels-tutorial.html&title=Golang Channels Tutorial" rel="nofollow" target="_blank" title="Share on Reddit">Reddit</a>
</section>

</article>


			</section>

			<footer class="main-footer">
				<section class="copyright">&copy; Copyright 2021 by Alexander Guz • <a target="_blank" href="/feed.xml">RSS</a></section>
			</footer>
		</section>
	</section>

	<script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-31916607-1']);
		_gaq.push(['_setDomainName', 'guzalexander.com']);
		_gaq.push(['_trackPageview']);

		(function () {
            var ga = document.createElement('script');ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' === document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(ga, s);
		})();
	</script>

</body>

</html>
